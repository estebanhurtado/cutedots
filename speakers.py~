import os
import numpy as np
import dotsio as dio
import analysis as an
import trajdata as td
import copy
import modelops as mops

def makeSegmentation(indir,outdir,min_seconds,window_width):
    for dirpath, dirnames, filenames in os.walk(indir):
        for fn in filenames:
            if fn.endswith('.qtd'):
                key = dirpath[len(indir):]
                fullfn = os.path.join(dirpath, fn)
                directory = '{}{}_{}'.format(outdir,fn[:-4],'SEGMENTS')
                if not os.path.exists(directory):
                    os.makedirs(directory)
                td = dio.trajDataFromH5(fullfn, progress=None)
                e1 = movAvgFilter(td,window_width,1)
                e2 = movAvgFilter(td,window_width,2)
                td_aux = td
                findSpeaker(e1,e2,min_seconds,td_aux,fn,directory)
                

def movAvgFilter(trajData,window_width,subject_id):
    window_vec = np.ones(window_width,'d')
    window_filt = window_vec/window_vec.sum()
    if (subject_id == 2):
        subj = [t for t in trajData.trajs if t.subject == 2]
    else:
        subj = [t for t in trajData.trajs if t.subject == 1]
    e = an.energy(subj, transform=lambda x: x)
    e_filt = np.convolve(window_filt,e,mode='valid')
    return e_filt


def findSpeaker(e1,e2,min_seconds,trajData,fn,directory):
    zero_crossings = np.where(np.absolute(np.diff(np.sign(e1-e2)))>=2)[0]
    #valid_segments = np.where(np.diff(zero_crossings)>2000)[0]
    spkr_frame1 = np.where(e1[0]-e2[0] > 0,1,2)
    speaker = np.concatenate((spkr_frame1*np.ones(1),np.where(e1[zero_crossings+1]-e2[zero_crossings+1] > 0,1,2)),axis=0)
    zc_left = np.concatenate((np.zeros(1),zero_crossings[:]+1),axis=1)
    zc_right = np.concatenate((zero_crossings[:],len(e1)*np.ones(1)),axis=1)
    min_frames = min_seconds*trajData.framerate
    theSegmentator(zc_left,zc_right,speaker,trajData,fn,directory)    

# TO DO    
#def checkLength(zc_left,zc_right,speaker,min_frames):
    
def theSegmentator(zc_left,zc_right,speaker,trajData,fn,directory):
    i = 0
    for zc in zc_right:
        td_aux2 = copy.deepcopy(trajData) # Creo que hay una forma m√°s inteligente de hacer esto
        td_aux2.cutRight(int(zc_right[i]))
        td_aux2.cutLeft(int(zc_left[i]))                 
        fntemp = '{}_{}{}'.format(fn[:-4], i,'.qtd')
        td_aux2.filename = os.path.join(directory, fntemp)
        if (speaker[i] == 2):
            swapSubjectsAux(td_aux2)
        dio.trajDataSaveH5(td_aux2, progress=None) 
        i += 1


def rotate90DegAux(data):
    trajNum = 0
    numTrajs = data.numTrajs
    for traj in data.trajs:
        for i in range(traj.numFrames):
            x, y, z = traj.pointData[i]
            traj.pointData[i] = -y, x, z
        trajNum += 1
    data.changed = True
    

def swapSubjectsAux(data):
    for traj in data.trajs:
        n = traj.name
        if n[3] == '1':
            traj.name = n[:3] + '2'
        elif n[3] == '2':
            traj.name = n[:3] + '1'
    rotate90DegAux(data)
    rotate90DegAux(data)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--infolder')
    parser.add_argument('--outfolder')
    args = parser.parse_args()
    
    makeSegmentation(args.infolder, args.outfolder, 10, 500)
